package org.csa.facets.infra;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

/**
 * One aspect that works for both production and tests.
 *
 * VM properties (all optional):
 *   -Dusage.enabled=true|false        (default: true)
 *   -Dusage.scope=app|catchall        (default: app)
 *   -Dusage.basePackage=org.csa.facets (default: org.csa.facets)
 *   -Dusage.maxLinesPerMethod=200     (default: 200)
 *
 * "app" logs only classes whose FQN starts with basePackage.
 * "catchall" logs all compiled classes (except getters/setters and this aspect).
 * Prints a summary at JVM shutdown.
 */
@Aspect
public class MethodUsageAspect {

    // ----- Config (read once at class load) -----
    private static final boolean ENABLED =
            Boolean.parseBoolean(System.getProperty("usage.enabled", "true"));
    private static final String SCOPE =
            System.getProperty("usage.scope", "app").trim().toLowerCase(); // app | catchall
    private static final String BASE_PKG =
            System.getProperty("usage.basePackage", "org.csa.facets");
    private static final int MAX_LINES_PER_METHOD =
            Math.max(1, Integer.parseInt(System.getProperty("usage.maxLinesPerMethod", "200")));

    // ----- State -----
    private static final ConcurrentHashMap<String, LongAdder> COUNTS = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, RingBuffer> CALLS = new ConcurrentHashMap<>();
    private static final DateTimeFormatter TS_FMT =
            DateTimeFormatter.ISO_OFFSET_DATE_TIME.withZone(ZoneId.systemDefault());

    static {
        Runtime.getRuntime().addShutdownHook(new Thread(MethodUsageAspect::printSummary, "method-usage-summary"));
    }

    // Catch-all pointcut; we filter inside the advice to allow runtime toggling.
    @Before("execution(* *(..))"
          + " && !execution(* *.get*(..))"
          + " && !execution(* *.set*(..))"
          + " && !within(org.csa.facets.infra.MethodUsageAspect)")
    public void onEnter(JoinPoint jp) {
        if (!ENABLED) return;

        String typeName = jp.getSignature().getDeclaringTypeName();
        if ("app".equals(SCOPE) && (typeName == null || !typeName.startsWith(BASE_PKG))) {
            return; // only log your app package in "app" scope
        }

        String methodKey = typeName + "#" + jp.getSignature().getName();
        COUNTS.computeIfAbsent(methodKey, k -> new LongAdder()).increment();

        String ts = TS_FMT.format(Instant.now());
        String args = Arrays.toString(jp.getArgs());
        CALLS.computeIfAbsent(methodKey, k -> new RingBuffer(MAX_LINES_PER_METHOD))
             .add("[" + ts + "] " + methodKey + "(" + args + ")");
    }

    private static void printSummary() {
        if (!ENABLED) return;
        System.out.println("===== Method Usage Summary (" + SCOPE + "; base=" + BASE_PKG + ") =====");
        List<Map.Entry<String, LongAdder>> sorted = COUNTS.entrySet().stream()
                .sorted((a, b) -> Long.compare(b.getValue().sum(), a.getValue().sum()))
                .toList();
        for (Map.Entry<String, LongAdder> e : sorted) {
            String method = e.getKey();
            long count = e.getValue().sum();
            System.out.printf("%8d  %s%n", count, method);
            RingBuffer rb = CALLS.get(method);
            if (rb != null) rb.forEach(line -> System.out.println("          " + line));
        }
        System.out.println("=================================================");
    }

    /** Tiny synchronized ring buffer to cap memory. */
    private static final class RingBuffer {
        private final String[] buf;
        private int i = 0, n = 0;
        RingBuffer(int capacity) { this.buf = new String[capacity]; }
        synchronized void add(String s) { buf[i] = s; i = (i + 1) % buf.length; if (n < buf.length) n++; }
        synchronized void forEach(java.util.function.Consumer<String> c) {
            int start = (i - n + buf.length) % buf.length;
            for (int k = 0; k < n; k++) c.accept(buf[(start + k) % buf.length]);
        }
    }
}