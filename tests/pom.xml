<plugin>
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>aspectj-maven-plugin</artifactId>
  <version>1.15.0</version>
  <configuration>
    <!-- Do NOT set <source>/<target>. Remove them everywhere. -->
    <!-- Try complianceLevel "17"; if you still get -17, switch to "1.8" temporarily to test. -->
    <complianceLevel>17</complianceLevel>

    <encoding>UTF-8</encoding>
    <showWeaveInfo>true</showWeaveInfo>
    <verbose>true</verbose>

    <!-- Explicit sources so ajc never says "no sources specified" -->
    <sources>
      <source>
        <basedir>${project.build.sourceDirectory}</basedir>
        <includes>
          <include>**/*.java</include>
        </includes>
      </source>
    </sources>

    <!-- Weave self-invocations -->
    <weaveMainSourceFolder>true</weaveMainSourceFolder>
  </configuration>
  <executions>
    <execution>
      <goals>
        <goal>compile</goal>
        <goal>test-compile</goal>
      </goals>
    </execution>
  </executions>
</plugin>




package org.csa.facets.infra;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

import java.io.*;
import java.net.InetAddress;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.LongAdder;

// MongoDB driver (make sure the driver is on your classpath)
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;

/**
 * Catch-all method usage logger (works for tests and the packaged JAR).
 * - Counts and stores last N invocations (timestamp + args)
 * - Prints a summary at shutdown
 * - Also writes the same lines to MongoDB at shutdown
 */
@Aspect
public class MethodUsageAspect {

    // ======= Config (override with -D if you like; no flags needed by default) =======
    private static final int MAX_LINES_PER_METHOD = Integer.getInteger("usage.maxLinesPerMethod", 200);

    private static final boolean MONGO_ENABLED = Boolean.parseBoolean(System.getProperty("usage.mongo.enabled", "true"));
    // The properties file to read (first from classpath, then as a file). Change default to match your env.
    private static final String MONGO_CONFIG_FILE = System.getProperty("usage.mongo.configFile", "cfm.config");
    private static final String MONGO_URI_PROP_KEY = System.getProperty("usage.mongo.uriProperty", "mongodburi");
    private static final String MONGO_DB = System.getProperty("usage.mongo.db", "CNSTeamPlayground");
    private static final String MONGO_COLLECTION = System.getProperty("usage.mongo.collection", "cs_Automation_APILog_Facets");

    // ======= Storage =======
    private static final ConcurrentHashMap<String, LongAdder> COUNTS = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<String, RingBuffer> CALLS = new ConcurrentHashMap<>();

    private static final DateTimeFormatter TS_FMT =
            DateTimeFormatter.ISO_OFFSET_DATE_TIME.withZone(ZoneId.systemDefault());

    static {
        Runtime.getRuntime().addShutdownHook(new Thread(MethodUsageAspect::onShutdown, "method-usage-summary"));
    }

    // Catch-all for your compiled classes; skip getters/setters and this aspect itself.
    @Before("execution(* *(..))"
          + " && !execution(* *.get*(..))"
          + " && !execution(* *.set*(..))"
          + " && !within(org.csa.facets.infra.MethodUsageAspect)")
    public void onEnter(JoinPoint jp) {
        String typeName = jp.getSignature().getDeclaringTypeName();
        String methodKey = typeName + "#" + jp.getSignature().getName();

        COUNTS.computeIfAbsent(methodKey, k -> new LongAdder()).increment();

        String ts = TS_FMT.format(Instant.now());
        String args = Arrays.toString(jp.getArgs());
        CALLS.computeIfAbsent(methodKey, k -> new RingBuffer(MAX_LINES_PER_METHOD))
             .add("[" + ts + "] " + methodKey + "(" + args + ")");
    }

    private static void onShutdown() {
        printSummary();
        if (MONGO_ENABLED) {
            try {
                flushToMongo();
            } catch (Exception e) {
                System.err.println("MethodUsageAspect: Failed to write logs to MongoDB: " + e.getMessage());
            }
        }
    }

    // ======= Console summary =======
    private static void printSummary() {
        System.out.println("===== Method Usage Summary =====");
        List<Map.Entry<String, LongAdder>> sorted = new ArrayList<>(COUNTS.entrySet());
        sorted.sort((a, b) -> Long.compare(b.getValue().sum(), a.getValue().sum()));
        for (Map.Entry<String, LongAdder> e : sorted) {
            String method = e.getKey();
            long count = e.getValue().sum();
            System.out.printf("%8d  %s%n", count, method);
            RingBuffer rb = CALLS.get(method);
            if (rb != null) rb.forEach(line -> System.out.println("          " + line));
        }
        System.out.println("================================");
    }

    // ======= MongoDB flush =======
    private static void flushToMongo() throws Exception {
        Properties props = loadProps(MONGO_CONFIG_FILE);
        String uri = props.getProperty(MONGO_URI_PROP_KEY);
        if (uri == null || uri.trim().isEmpty()) {
            throw new IllegalStateException("Property '" + MONGO_URI_PROP_KEY + "' not found in " + MONGO_CONFIG_FILE);
        }

        String userName = System.getProperty("user.name", "unknown");
        String machineName;
        try { machineName = InetAddress.getLocalHost().getHostName(); }
        catch (Exception e) { machineName = "unknown"; }

        try (MongoClient client = MongoClients.create(uri)) {
            MongoDatabase db = client.getDatabase(MONGO_DB);
            MongoCollection<Document> col = db.getCollection(MONGO_COLLECTION);

            // Build documents: one per invocation line, plus one summary per method.
            List<Document> docs = new ArrayList<>();

            for (Map.Entry<String, LongAdder> e : COUNTS.entrySet()) {
                String method = e.getKey();
                long count = e.getValue().sum();

                // Summary doc
                Document sum = new Document("type", "summary")
                        .append("username", userName)
                        .append("machineName", machineName)
                        .append("timestamp", new Date())
                        .append("method", method)
                        .append("count", count);
                docs.add(sum);

                // Per-call docs (bounded by ring buffer)
                RingBuffer rb = CALLS.get(method);
                if (rb != null) {
                    rb.forEach(line -> {
                        // Try to split our line: "[ts] Class#method(args...)"
                        String tsStr = null;
                        try {
                            int r = line.indexOf(']');
                            if (line.startsWith("[") && r > 1) tsStr = line.substring(1, r);
                        } catch (Exception ignore) { /* no-op */ }

                        Document call = new Document("type", "call")
                                .append("username", userName)
                                .append("machineName", machineName)
                                .append("timestamp", tsStr != null ? tsStr : TS_FMT.format(Instant.now()))
                                .append("logMessage", line);
                        docs.add(call);
                    });
                }
            }

            if (!docs.isEmpty()) {
                col.insertMany(docs);
            }
        }
    }

    private static Properties loadProps(String fileName) throws IOException {
        Properties p = new Properties();
        InputStream in = MethodUsageAspect.class.getResourceAsStream("/" + fileName);
        if (in != null) {
            try (BufferedInputStream bis = new BufferedInputStream(in)) { p.load(bis); }
            return p;
        }
        try (FileInputStream fis = new FileInputStream(fileName)) { p.load(fis); }
        return p;
    }

    // ======= Small synchronized ring buffer =======
    private static final class RingBuffer {
        private final String[] buf;
        private int i = 0, n = 0;
        RingBuffer(int capacity) { this.buf = new String[Math.max(1, capacity)]; }
        synchronized void add(String s) { buf[i] = s; i = (i + 1) % buf.length; if (n < buf.length) n++; }
        synchronized void forEach(java.util.function.Consumer<String> c) {
            int start = (i - n + buf.length) % buf.length;
            for (int k = 0; k < n; k++) c.accept(buf[(start + k) % buf.length]);
        }
    }
}
